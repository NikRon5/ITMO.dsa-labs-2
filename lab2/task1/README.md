# Задание №1. Обход двоичного дерева (1 балл)

## Задание

В этой задаче вы реализуете три основных способа обхода двоичного дерева «в глубину»: 
центрированный (in-order), прямой (pre-order) и обратный (post-order). 
Очень полезно попрактиковаться в их реализации, чтобы лучше понять бинарные деревья поиска.

Вам дано корневое двоичное дерево. Выведите центрированный (in-order), 
прямой (pre-order) и обратный (post-order) обходы в глубину.

- Формат ввода: стандартный ввод или input.txt. В первой строке входного файла содержится количество узлов
n. Узлы дерева пронумерованы от 0 до n − 1. Узел 0 является корнем.
Следующие n строк содержат информацию об узлах 0, 1, ..., n − 1 по порядку. Каждая из этих строк содержит
три целых числа Ki, Li и Ri. Ki – ключ i-го узла, Li - индекс левого ребенка i-го узла, а Ri - индекс правого
ребенка i-го узла. Если у i-го узла нет левого или правого ребенка (или обоих), соответствующие числа Li или
Ri (или оба) будут равны −1.
- Ограничения на входные данные. 1 ≤ n ≤ 105, 0 ≤ Ki ≤ 109, −1 ≤ Li, Ri ≤ n−1. 
Гарантируется, что данное дерево является двоичным деревом. В частности, если Li ̸= −1 и Ri ̸= −1, то Li ̸= Ri

- Кроме того, узел не может быть ребенком двух разных узлов. Кроме того, каждый узел является потомком корневого узла.
- Формат вывода / выходного файла (output.txt). Выведите три строки. Первая строка должна содержать ключи
узлов при центрированном обходе дерева (in-order). Вторая строка должна содержать ключи узлов при прямом
обходе дерева (pre-order). Третья строка должна содержать ключи узлов при обратном обходе дерева (post-order).

## Ограничения по времени и памяти
- Ограничение по времени. 5 сек.
- Ограничение по памяти. 512 мб.